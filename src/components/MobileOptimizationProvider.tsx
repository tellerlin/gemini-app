import React, { createContext, useContext, useEffect, useState, useCallback, ReactNode } from 'react';

interface TouchInteraction {
  startX: number;
  startY: number;
  startTime: number;
  element: HTMLElement;
}

interface MobileOptimizationContextType {
  isMobile: boolean;
  isTablet: boolean;
  screenSize: 'sm' | 'md' | 'lg' | 'xl';
  orientation: 'portrait' | 'landscape';
  safeAreaInsets: {
    top: number;
    bottom: number;
    left: number;
    right: number;
  };
  devicePixelRatio: number;
  prefersDarkMode: boolean;
  prefersReducedMotion: boolean;
  addSwipeGesture: (element: HTMLElement, onSwipe: (direction: 'left' | 'right' | 'up' | 'down') => void) => () => void;
  vibrate: (pattern?: number | number[]) => void;
}

const MobileOptimizationContext = createContext<MobileOptimizationContextType | null>(null);

interface MobileOptimizationProviderProps {
  children: ReactNode;
}

export function MobileOptimizationProvider({ children }: MobileOptimizationProviderProps) {
  const [isMobile, setIsMobile] = useState(false);
  const [isTablet, setIsTablet] = useState(false);
  const [screenSize, setScreenSize] = useState<'sm' | 'md' | 'lg' | 'xl'>('md');
  const [orientation, setOrientation] = useState<'portrait' | 'landscape'>('portrait');
  const [safeAreaInsets, setSafeAreaInsets] = useState({ top: 0, bottom: 0, left: 0, right: 0 });
  const [devicePixelRatio, setDevicePixelRatio] = useState(window.devicePixelRatio || 1);
  const [prefersDarkMode, setPrefersDarkMode] = useState(false);
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n  // Device detection\n  useEffect(() => {\n    const updateDeviceInfo = () => {\n      const width = window.innerWidth;\n      const height = window.innerHeight;\n      const userAgent = navigator.userAgent;\n      \n      // Mobile detection\n      const mobileCheck = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent) || width < 768;\n      setIsMobile(mobileCheck);\n      \n      // Tablet detection\n      const tabletCheck = /iPad|Android/i.test(userAgent) && width >= 768 && width < 1024;\n      setIsTablet(tabletCheck);\n      \n      // Screen size\n      if (width < 640) setScreenSize('sm');\n      else if (width < 768) setScreenSize('md');\n      else if (width < 1024) setScreenSize('lg');\n      else setScreenSize('xl');\n      \n      // Orientation\n      setOrientation(width > height ? 'landscape' : 'portrait');\n      \n      // Device pixel ratio\n      setDevicePixelRatio(window.devicePixelRatio || 1);\n    };\n\n    updateDeviceInfo();\n    window.addEventListener('resize', updateDeviceInfo);\n    window.addEventListener('orientationchange', updateDeviceInfo);\n\n    return () => {\n      window.removeEventListener('resize', updateDeviceInfo);\n      window.removeEventListener('orientationchange', updateDeviceInfo);\n    };\n  }, []);\n\n  // Safe area insets detection\n  useEffect(() => {\n    const updateSafeArea = () => {\n      const root = document.documentElement;\n      const computedStyle = getComputedStyle(root);\n      \n      setSafeAreaInsets({\n        top: parseInt(computedStyle.getPropertyValue('--safe-area-inset-top') || '0', 10),\n        bottom: parseInt(computedStyle.getPropertyValue('--safe-area-inset-bottom') || '0', 10),\n        left: parseInt(computedStyle.getPropertyValue('--safe-area-inset-left') || '0', 10),\n        right: parseInt(computedStyle.getPropertyValue('--safe-area-inset-right') || '0', 10),\n      });\n    };\n\n    updateSafeArea();\n    window.addEventListener('resize', updateSafeArea);\n    \n    return () => {\n      window.removeEventListener('resize', updateSafeArea);\n    };\n  }, []);\n\n  // Media query preferences\n  useEffect(() => {\n    const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    \n    const updateDarkMode = (e: MediaQueryListEvent) => setPrefersDarkMode(e.matches);\n    const updateReducedMotion = (e: MediaQueryListEvent) => setPrefersReducedMotion(e.matches);\n    \n    setPrefersDarkMode(darkModeQuery.matches);\n    setPrefersReducedMotion(reducedMotionQuery.matches);\n    \n    darkModeQuery.addListener(updateDarkMode);\n    reducedMotionQuery.addListener(updateReducedMotion);\n    \n    return () => {\n      darkModeQuery.removeListener(updateDarkMode);\n      reducedMotionQuery.removeListener(updateReducedMotion);\n    };\n  }, []);\n\n  // Enhanced swipe gesture detection\n  const addSwipeGesture = useCallback((\n    element: HTMLElement,\n    onSwipe: (direction: 'left' | 'right' | 'up' | 'down') => void\n  ) => {\n    let touchStart: TouchInteraction | null = null;\n    const minSwipeDistance = 50;\n    const maxSwipeTime = 300;\n    \n    const handleTouchStart = (e: TouchEvent) => {\n      const touch = e.touches[0];\n      touchStart = {\n        startX: touch.clientX,\n        startY: touch.clientY,\n        startTime: Date.now(),\n        element: element\n      };\n    };\n    \n    const handleTouchEnd = (e: TouchEvent) => {\n      if (!touchStart) return;\n      \n      const touch = e.changedTouches[0];\n      const deltaX = touch.clientX - touchStart.startX;\n      const deltaY = touch.clientY - touchStart.startY;\n      const deltaTime = Date.now() - touchStart.startTime;\n      \n      if (deltaTime > maxSwipeTime) {\n        touchStart = null;\n        return;\n      }\n      \n      const absDeltaX = Math.abs(deltaX);\n      const absDeltaY = Math.abs(deltaY);\n      \n      if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) {\n        touchStart = null;\n        return;\n      }\n      \n      if (absDeltaX > absDeltaY) {\n        // Horizontal swipe\n        onSwipe(deltaX > 0 ? 'right' : 'left');\n      } else {\n        // Vertical swipe\n        onSwipe(deltaY > 0 ? 'down' : 'up');\n      }\n      \n      touchStart = null;\n    };\n    \n    const handleTouchCancel = () => {\n      touchStart = null;\n    };\n    \n    element.addEventListener('touchstart', handleTouchStart, { passive: true });\n    element.addEventListener('touchend', handleTouchEnd, { passive: true });\n    element.addEventListener('touchcancel', handleTouchCancel, { passive: true });\n    \n    return () => {\n      element.removeEventListener('touchstart', handleTouchStart);\n      element.removeEventListener('touchend', handleTouchEnd);\n      element.removeEventListener('touchcancel', handleTouchCancel);\n    };\n  }, []);\n\n  // Haptic feedback\n  const vibrate = useCallback((pattern: number | number[] = 50) => {\n    if ('vibrate' in navigator && navigator.vibrate) {\n      navigator.vibrate(pattern);\n    }\n  }, []);\n\n  const value: MobileOptimizationContextType = {\n    isMobile,\n    isTablet,\n    screenSize,\n    orientation,\n    safeAreaInsets,\n    devicePixelRatio,\n    prefersDarkMode,\n    prefersReducedMotion,\n    addSwipeGesture,\n    vibrate,\n  };\n\n  return (\n    <MobileOptimizationContext.Provider value={value}>\n      {children}\n    </MobileOptimizationContext.Provider>\n  );\n}\n\nexport function useMobileOptimization() {\n  const context = useContext(MobileOptimizationContext);\n  if (!context) {\n    throw new Error('useMobileOptimization must be used within a MobileOptimizationProvider');\n  }\n  return context;\n}\n\n// Enhanced touch interaction hooks\nexport function useSwipeGesture(\n  onSwipe: (direction: 'left' | 'right' | 'up' | 'down') => void,\n  elementRef: React.RefObject<HTMLElement>\n) {\n  const { addSwipeGesture } = useMobileOptimization();\n  \n  useEffect(() => {\n    const element = elementRef.current;\n    if (!element) return;\n    \n    return addSwipeGesture(element, onSwipe);\n  }, [addSwipeGesture, onSwipe, elementRef]);\n}\n\n// Performance optimization for mobile\nexport function useMobilePerformance() {\n  const { isMobile, devicePixelRatio, prefersReducedMotion } = useMobileOptimization();\n  \n  const optimizeForMobile = useCallback((config: {\n    enableAnimations?: boolean;\n    imageQuality?: 'low' | 'medium' | 'high';\n    maxConcurrentRequests?: number;\n  }) => {\n    const { enableAnimations = true, imageQuality = 'medium', maxConcurrentRequests = 6 } = config;\n    \n    return {\n      shouldUseAnimations: enableAnimations && !prefersReducedMotion,\n      imageQuality: isMobile && devicePixelRatio > 2 ? 'high' : imageQuality,\n      maxConcurrentRequests: isMobile ? Math.min(maxConcurrentRequests, 3) : maxConcurrentRequests,\n      shouldPreloadImages: !isMobile,\n      shouldUseLazyLoading: isMobile,\n    };\n  }, [isMobile, devicePixelRatio, prefersReducedMotion]);\n  \n  return { optimizeForMobile };\n}