import { useState, useEffect, useCallback } from 'react';\nimport { toast } from 'react-hot-toast';\n\ninterface RateLimitInfo {\n  remaining: number;\n  resetTime: Date;\n  limit: number;\n  windowMs: number;\n}\n\ninterface RateLimitState {\n  [key: string]: RateLimitInfo;\n}\n\ninterface UseRateLimitOptions {\n  maxRequests?: number;\n  windowMs?: number;\n  onLimitExceeded?: (keyId: string, info: RateLimitInfo) => void;\n  onWarning?: (keyId: string, remaining: number) => void;\n  warningThreshold?: number;\n}\n\nexport function useRateLimit({\n  maxRequests = 60,\n  windowMs = 60 * 1000, // 1 minute\n  onLimitExceeded,\n  onWarning,\n  warningThreshold = 5\n}: UseRateLimitOptions = {}) {\n  const [rateLimitState, setRateLimitState] = useState<RateLimitState>({});\n  const [globalLimited, setGlobalLimited] = useState(false);\n\n  // Check if a specific key/endpoint is rate limited\n  const isLimited = useCallback((keyId: string): boolean => {\n    const info = rateLimitState[keyId];\n    if (!info) return false;\n    \n    const now = new Date();\n    if (now > info.resetTime) {\n      // Reset window has passed\n      return false;\n    }\n    \n    return info.remaining <= 0;\n  }, [rateLimitState]);\n\n  // Update rate limit for a key\n  const updateRateLimit = useCallback((keyId: string, responseHeaders?: Headers) => {\n    const now = new Date();\n    \n    setRateLimitState(prev => {\n      const current = prev[keyId];\n      let newInfo: RateLimitInfo;\n      \n      if (responseHeaders) {\n        // Parse rate limit headers from API response\n        const remaining = parseInt(responseHeaders.get('x-ratelimit-remaining') || '0');\n        const resetTime = responseHeaders.get('x-ratelimit-reset');\n        const limit = parseInt(responseHeaders.get('x-ratelimit-limit') || maxRequests.toString());\n        \n        newInfo = {\n          remaining,\n          resetTime: resetTime ? new Date(parseInt(resetTime) * 1000) : new Date(now.getTime() + windowMs),\n          limit,\n          windowMs\n        };\n      } else {\n        // Client-side rate limiting\n        if (!current || now > current.resetTime) {\n          // New window or reset window\n          newInfo = {\n            remaining: maxRequests - 1,\n            resetTime: new Date(now.getTime() + windowMs),\n            limit: maxRequests,\n            windowMs\n          };\n        } else {\n          // Decrement remaining in current window\n          newInfo = {\n            ...current,\n            remaining: Math.max(0, current.remaining - 1)\n          };\n        }\n      }\n      \n      // Trigger callbacks\n      if (newInfo.remaining <= 0 && onLimitExceeded) {\n        onLimitExceeded(keyId, newInfo);\n      } else if (newInfo.remaining <= warningThreshold && onWarning) {\n        onWarning(keyId, newInfo.remaining);\n      }\n      \n      return {\n        ...prev,\n        [keyId]: newInfo\n      };\n    });\n  }, [maxRequests, windowMs, onLimitExceeded, onWarning, warningThreshold]);\n\n  // Get time until rate limit resets\n  const getResetTime = useCallback((keyId: string): number => {\n    const info = rateLimitState[keyId];\n    if (!info) return 0;\n    \n    const now = new Date();\n    return Math.max(0, info.resetTime.getTime() - now.getTime());\n  }, [rateLimitState]);\n\n  // Get remaining requests for a key\n  const getRemaining = useCallback((keyId: string): number => {\n    const info = rateLimitState[keyId];\n    if (!info) return maxRequests;\n    \n    const now = new Date();\n    if (now > info.resetTime) {\n      return maxRequests; // Window has reset\n    }\n    \n    return info.remaining;\n  }, [rateLimitState, maxRequests]);\n\n  // Check global rate limiting across all keys\n  useEffect(() => {\n    const allLimited = Object.values(rateLimitState).every(info => {\n      const now = new Date();\n      return now <= info.resetTime && info.remaining <= 0;\n    });\n    \n    if (allLimited && Object.keys(rateLimitState).length > 0) {\n      setGlobalLimited(true);\n      const resetTimes = Object.values(rateLimitState).map(info => info.resetTime.getTime());\n      const nextReset = Math.min(...resetTimes);\n      const waitTime = nextReset - Date.now();\n      \n      if (waitTime > 0) {\n        toast.error(`Rate limited on all keys. Retry in ${Math.ceil(waitTime / 1000)}s`, {\n          duration: Math.min(waitTime, 10000)\n        });\n        \n        setTimeout(() => {\n          setGlobalLimited(false);\n        }, waitTime);\n      }\n    } else {\n      setGlobalLimited(false);\n    }\n  }, [rateLimitState]);\n\n  // Auto-cleanup expired rate limit entries\n  useEffect(() => {\n    const cleanup = setInterval(() => {\n      const now = new Date();\n      setRateLimitState(prev => {\n        const updated = { ...prev };\n        let hasChanges = false;\n        \n        Object.keys(updated).forEach(keyId => {\n          if (now > updated[keyId].resetTime) {\n            delete updated[keyId];\n            hasChanges = true;\n          }\n        });\n        \n        return hasChanges ? updated : prev;\n      });\n    }, 30000); // Cleanup every 30 seconds\n    \n    return () => clearInterval(cleanup);\n  }, []);\n\n  return {\n    isLimited,\n    updateRateLimit,\n    getResetTime,\n    getRemaining,\n    globalLimited,\n    rateLimitState\n  };\n}