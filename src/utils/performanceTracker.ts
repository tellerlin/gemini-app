/**\n * Performance monitoring utility for tracking optimization results\n */\n\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  unit: string;\n  timestamp: number;\n  category: 'bundle' | 'runtime' | 'memory' | 'network';\n}\n\nexport class PerformanceTracker {\n  private static metrics: PerformanceMetric[] = [];\n  private static observer?: PerformanceObserver;\n  \n  /**\n   * Initialize performance tracking\n   */\n  static init(): void {\n    if (typeof window === 'undefined') return;\n    \n    // Track bundle metrics\n    this.trackBundleMetrics();\n    \n    // Track runtime metrics\n    this.trackRuntimeMetrics();\n    \n    // Track memory usage\n    this.trackMemoryMetrics();\n    \n    // Track Core Web Vitals\n    this.trackWebVitals();\n    \n    console.log('ðŸš€ Performance tracking initialized');\n  }\n  \n  /**\n   * Track bundle size and loading metrics\n   */\n  private static trackBundleMetrics(): void {\n    // Track initial bundle load time\n    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n    \n    if (navigation) {\n      this.addMetric({\n        name: 'DOM Content Loaded',\n        value: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\n        unit: 'ms',\n        timestamp: Date.now(),\n        category: 'bundle'\n      });\n      \n      this.addMetric({\n        name: 'Page Load Complete',\n        value: navigation.loadEventEnd - navigation.loadEventStart,\n        unit: 'ms',\n        timestamp: Date.now(),\n        category: 'bundle'\n      });\n    }\n    \n    // Track resource loading\n    const resources = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n    const jsResources = resources.filter(r => r.name.includes('.js'));\n    \n    const totalJSSize = jsResources.reduce((sum, resource) => {\n      return sum + (resource.transferSize || 0);\n    }, 0);\n    \n    this.addMetric({\n      name: 'Total JS Bundle Size',\n      value: totalJSSize,\n      unit: 'bytes',\n      timestamp: Date.now(),\n      category: 'bundle'\n    });\n  }\n  \n  /**\n   * Track runtime performance metrics\n   */\n  private static trackRuntimeMetrics(): void {\n    // Track component render times\n    let componentRenderCount = 0;\n    let totalRenderTime = 0;\n    \n    // Override React render timing (development only)\n    if (process.env.NODE_ENV === 'development') {\n      const originalRequestIdleCallback = window.requestIdleCallback;\n      if (originalRequestIdleCallback) {\n        window.requestIdleCallback = function(callback, options) {\n          const start = performance.now();\n          return originalRequestIdleCallback(() => {\n            const end = performance.now();\n            totalRenderTime += end - start;\n            componentRenderCount++;\n            callback({\n              didTimeout: false,\n              timeRemaining: () => 0\n            });\n          }, options);\n        };\n      }\n    }\n    \n    // Track FPS\n    let lastFrameTime = performance.now();\n    let frameCount = 0;\n    \n    const trackFPS = () => {\n      const now = performance.now();\n      frameCount++;\n      \n      if (now - lastFrameTime >= 1000) {\n        this.addMetric({\n          name: 'Frames Per Second',\n          value: Math.round(frameCount * 1000 / (now - lastFrameTime)),\n          unit: 'fps',\n          timestamp: Date.now(),\n          category: 'runtime'\n        });\n        \n        frameCount = 0;\n        lastFrameTime = now;\n      }\n      \n      requestAnimationFrame(trackFPS);\n    };\n    \n    requestAnimationFrame(trackFPS);\n  }\n  \n  /**\n   * Track memory usage\n   */\n  private static trackMemoryMetrics(): void {\n    if ('memory' in performance) {\n      const memory = (performance as any).memory;\n      \n      setInterval(() => {\n        this.addMetric({\n          name: 'JS Heap Used',\n          value: memory.usedJSHeapSize,\n          unit: 'bytes',\n          timestamp: Date.now(),\n          category: 'memory'\n        });\n        \n        this.addMetric({\n          name: 'JS Heap Total',\n          value: memory.totalJSHeapSize,\n          unit: 'bytes',\n          timestamp: Date.now(),\n          category: 'memory'\n        });\n      }, 5000); // Track every 5 seconds\n    }\n  }\n  \n  /**\n   * Track Core Web Vitals\n   */\n  private static trackWebVitals(): void {\n    // Import web-vitals library dynamically if available\n    import('web-vitals').then(({ onCLS, onFID, onFCP, onLCP, onTTFB }) => {\n      onCLS((metric) => {\n        this.addMetric({\n          name: 'Cumulative Layout Shift',\n          value: metric.value,\n          unit: 'score',\n          timestamp: Date.now(),\n          category: 'runtime'\n        });\n      });\n      \n      onFID((metric) => {\n        this.addMetric({\n          name: 'First Input Delay',\n          value: metric.value,\n          unit: 'ms',\n          timestamp: Date.now(),\n          category: 'runtime'\n        });\n      });\n      \n      onFCP((metric) => {\n        this.addMetric({\n          name: 'First Contentful Paint',\n          value: metric.value,\n          unit: 'ms',\n          timestamp: Date.now(),\n          category: 'runtime'\n        });\n      });\n      \n      onLCP((metric) => {\n        this.addMetric({\n          name: 'Largest Contentful Paint',\n          value: metric.value,\n          unit: 'ms',\n          timestamp: Date.now(),\n          category: 'runtime'\n        });\n      });\n      \n      onTTFB((metric) => {\n        this.addMetric({\n          name: 'Time to First Byte',\n          value: metric.value,\n          unit: 'ms',\n          timestamp: Date.now(),\n          category: 'network'\n        });\n      });\n    }).catch(() => {\n      console.log('Web Vitals library not available');\n    });\n  }\n  \n  /**\n   * Add a performance metric\n   */\n  private static addMetric(metric: PerformanceMetric): void {\n    this.metrics.push(metric);\n    \n    // Keep only last 100 metrics to prevent memory bloat\n    if (this.metrics.length > 100) {\n      this.metrics = this.metrics.slice(-100);\n    }\n    \n    // Log significant metrics\n    if (this.isSignificantMetric(metric)) {\n      console.log(`ðŸ“Š ${metric.name}: ${metric.value}${metric.unit}`);\n    }\n  }\n  \n  /**\n   * Check if metric is significant enough to log\n   */\n  private static isSignificantMetric(metric: PerformanceMetric): boolean {\n    const significantMetrics = [\n      'DOM Content Loaded',\n      'Page Load Complete',\n      'First Contentful Paint',\n      'Largest Contentful Paint',\n      'Total JS Bundle Size'\n    ];\n    \n    return significantMetrics.includes(metric.name);\n  }\n  \n  /**\n   * Get all metrics\n   */\n  static getMetrics(): PerformanceMetric[] {\n    return [...this.metrics];\n  }\n  \n  /**\n   * Get metrics by category\n   */\n  static getMetricsByCategory(category: PerformanceMetric['category']): PerformanceMetric[] {\n    return this.metrics.filter(m => m.category === category);\n  }\n  \n  /**\n   * Get performance summary\n   */\n  static getSummary() {\n    const latest = (name: string) => {\n      const metric = this.metrics.filter(m => m.name === name).pop();\n      return metric ? `${metric.value}${metric.unit}` : 'N/A';\n    };\n    \n    return {\n      bundleSize: latest('Total JS Bundle Size'),\n      domContentLoaded: latest('DOM Content Loaded'),\n      firstContentfulPaint: latest('First Contentful Paint'),\n      largestContentfulPaint: latest('Largest Contentful Paint'),\n      jsHeapUsed: latest('JS Heap Used'),\n      fps: latest('Frames Per Second'),\n      metricsCount: this.metrics.length\n    };\n  }\n  \n  /**\n   * Export metrics for analysis\n   */\n  static exportMetrics(): string {\n    return JSON.stringify({\n      timestamp: new Date().toISOString(),\n      metrics: this.metrics,\n      summary: this.getSummary(),\n      userAgent: navigator.userAgent\n    }, null, 2);\n  }\n}\n\n// Auto-initialize if in browser environment\nif (typeof window !== 'undefined') {\n  // Initialize after a short delay to ensure app is ready\n  setTimeout(() => {\n    PerformanceTracker.init();\n  }, 1000);\n}